# 디자인 패턴
## 정의
- 소프트웨어의 아키텍처를 디자인할 때 자주 발생하는 문제들에 대한 해결책을 일반화
> 예시 : 개발자들에게 One App GUI를 제공하여 클라우드 벤더에 대한 신경을 쓰지 않고 개발할 수 있도록 해주는 플랫폼을 개발
>> 고민 포인트 : 멀티 클라우드에 대한 프로비저닝을 개발하기 위해 각 CSP에 대한 공통 및 개별 기능을 효율적으로 개발하기 위해 디렉터리 구조를 어떻게 가져가야할까?

## 분류
- 생성 패턴 : 기존 코드의 유연성 및 재사용성을 증가시키는 ***객체를 생성***하는데 필요한 디자인 패턴
- 구조 패턴 : 구조를 유연하고 효율적으로 유지하면서 ***객체들과 인터페이스들을 더 큰 구조로 조립***하는 방법을 제공하기 위한 디자인 패턴
- 행동 패턴 : ***객체와 인터페이스 사이의 알고리즘 혹은 책임 분배***를 정리한 디자인 패턴
  - 한 객체가 수행할 수 없는 작업을 어떤 기준으로 여러 개의 객체로 나누어 분배해야 객체 간 결합도가 최소화될지 중점

# 추상 팩토리 패턴 (Abstract Factory)
## 정의
- 연관성 있는 여러 객체들을 하나의 객체로 묶어 추상화하여 특정 상황에 따라 팩토리 객체를 통해 각 객체의 기능을 구현하는 생성 패턴

## Use Case
### 문제
멀티 클라우드에 대한 프로비저닝을 개발하기 위해 각 CSP에 대한 공통 및 개별 기능을 효율적으로 개발하기 위해 객체 생성과 기능을 어떻게 구현해야될까?

### 해결 방안 : 추상 팩토리 패턴
- 각 제품 (VM, RDB, Managed K8s 등)에 대한 Interface (리소스 스펙 가져오기, DB 테이블 생성 등이 정의된 interface) 및 Struct(VM, RDB, Managed K8s 등)을 정의
- 각 제품군(AWS, Azure, GCP)을 생성/삭제하는 공통 기능을 Factory Interface로 정의
- 각 제품군에 대한 Struct (AwsProvider)와 각 제품에 대한 Struct (EC2, RDS, EKS 등)을 생성
- Factory Interface에서 정의한 함수들을 각 제품군에 간접 참조로 구현
- Factory Interface가 정의된 GO 파일에서 각 객체를 생성할 수 있는 함수 구현

## 장점
- 객체 생성 코드를 분리함으로써 Client 코드와의 결합도를 낮출 수 있음
- 제품군을 쉽게 대체할 수 있음
- 단일 책임 원칙 준수
- 개방 / 폐쇄 원칙 준수

## 단점
- 각 구현체마다 팩토리 객체들을 모두 구현해주어야하기 때문에 객체가 증가할 경우 지속적으로 go 파일을 생성함으로써 코드 복잡성 증가
- Factory Interface 세부사항이 변경될 경우 모든 객체들에 수정이 필요
- 새로운 종류의 제품을 지원하는 것이 어려움 (신규 제품 추가 시 Factory 구현 로직 자체를 변경해야 됨)
